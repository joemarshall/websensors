<script language="javascript">
window.sensor_objects=[];
</script>

<script src="{{ '/assets/js/fake_worker.js' | relative_url }}"></script>


{% if page.uses_files %}
{% include onedrive.html %}
{% endif %}

{% if page.uses_audio %}

<script type="module">    

let snd_sensor={
    name:"sound",
    mod_snd:undefined,
    requestPermissions: function(){return this.mod_snd.requestPermissions()},
    init: async function(){this.mod_snd=await import("{{ 'assets/js/sound_sensor.js' | relative_url }} ");},
    start: async function(callback){await this.mod_snd.start(callback)},
    stop: async function() { await this.mod_snd.stop();}
};

window.sensor_objects.push(snd_sensor);
</script>
{% endif %}

{% if page.uses_light %}
<script type="module">    

let light_sensor={
    name:"light",
    mod_light:undefined,
    requestPermissions: function(){return this.mod_light.requestPermissions()},
    init: async function(){this.mod_light=await import("{{ 'assets/js/light_sensor.js' | relative_url }} ");},
    start: async function(callback){await this.mod_light.start(callback)},
    stop: async function() { await this.mod_light.stop();}
};

window.sensor_objects.push(light_sensor);
</script>
{% endif %}


{% if page.uses_accelerometer %}
<script type="module">
let accel_sensor={
    name:"accel",
    mod_accel:undefined,
    init: async function(){this.mod_accel=await import("{{ 'assets/js/accel_sensor.js' | relative_url }}");},
    requestPermissions: function(){return this.mod_accel.requestPermissions()},
    start: async function(callback){await this.mod_accel.startAccelerometer(callback)},
    stop: async function() { await this.mod_accel.stopAccelerometer();}
};

window.sensor_objects.push(accel_sensor);
</script>
{% endif %}


<script>
// make a pyodide box function
window.queued_pyodide_boxes=[]
function makePyodideBox(options)
{
    if(!options)
    {
        options={}
    }
    if(!options.parent)
    {
        // no parent, add a div here and pass that in
        let div=document.createElement("div");
        let script = document.scripts[document.scripts.length - 1]; // A reference to the currently running script

        div.className="pyodide_box";
        script.parentNode.insertBefore(div,script);
        options.parent=div;
    }
    if(window.makePyodideBoxInternal)
    {
        window.makePyodideBoxInternal(options);
    }else
    {
        window.queued_pyodide_boxes.push(options)
    }
}
</script>
<script src="{{ '/assets/js/codemirror.js' | relative_url }}" ></script>

<script type="module">
import {makeGraphContext} from "{{ '/assets/js/py_graphs.js' || relative_url }}";
import {Console} from "{{ '/assets/js/console.js' || relative_url }}";

let responseWaiter={};
let pythonInitPromise;

let box_index=0;

async function makePyodideBoxInternal(options)
{    
    box_index+=1;
    let parent=options.parent;
    let consoleDiv;
    let consoleObj;
    let editorDiv;
    let editor;
    let codeValue;
    let graphCanvas;
    let graphContext;

    let figureCap;
    let figure;

    let editorListener;



    if(options.caption)
    {
        figure=document.createElement("figure");
        figureCap=document.createElement("figcaption")
        figureCap.innerText=options.caption;
        parent.appendChild(figure);
        parent=figure;
    }
    if(options.codeString)
    {
        codeValue=options.codeString;
    }else if(options.codeFile)
    {
        codeValue=await (await fetch('{{ "/assets/python/" | relative_url }}' +options.codeFile)).text();
    }
    if(options.showCode || options.editable)
    {
{% if page.uses_files %}
        if(options.showFileButtons)
        {
            let filesDiv=document.createElement("div");
            filesDiv.className="files";
            let loginButton=document.createElement("Button");
            let openButton=document.createElement("Button");
            let saveButton=document.createElement("Button");
            let changeFolderButton=document.createElement("Button");
            let filenameBox=document.createElement("input");
            let folderBox=document.createElement("div")
            folderBox.innerText="";
            loginButton.innerText="Login onedrive";
            filenameBox.type="text";
            filenameBox.value="";
            openButton.innerText="Open...";
            saveButton.innerText="Save";
            changeFolderButton.innerText="Change folder...";
            openButton.onclick=function()
            {
                oneDriveOpen(function(fileText,filename,foldername)
                {                    
                    filenameBox.value=filename;
                    var doc=editor.state.doc;
                    let transaction = editor.state.update({changes: {from: 0, to: doc.length, insert: fileText}})
                    editor.dispatch(transaction);
                    editor.state.values[0].done=[];
                    editor.state.values[0].undone=[];
                    folderBox.innerText=foldername;
                });
            }
            saveButton.onclick=function()
            {
                let filename=filenameBox.value;
                oneDriveSaveAs(editor.state.doc.toString(),filename);                
                saveButton.innerText="Save";
            };
            changeFolderButton.onclick=function()
            {
                let filename=filenameBox.value;
                oneDriveChooseFolder(filename,false).then(function(foldername)
                {
                    folderBox.innerText=foldername;
                });
            };
            loginButton.onclick=async function()
            {
                if(oneDriveLoggedIn())
                {
                    await msLogout();
                }else
                {
                    await msLogin(true);
                }
                if(oneDriveLoggedIn())
                {
                    loginButton.innerText="Logout onedrive";
                }else
                {
                    loginButton.innerText="Login onedrive";
                }
            };
            filesDiv.appendChild(loginButton);
            filesDiv.appendChild(openButton);
            filesDiv.appendChild(saveButton);
            filesDiv.appendChild(changeFolderButton);
            filesDiv.appendChild(folderBox);
            filesDiv.appendChild(filenameBox);
            parent.appendChild(filesDiv);
            // on reload, load up the previous onedrive file if there is 
            // still one in the session
            var token=await msLogin(false);
            if(token)
            {
                loginButton.innerText="Logout onedrive";
                oneDriveReload(function(fileText,filename,foldername,logfolder)
                {
                    if(foldername)
                    {
                        folderBox.innerText=foldername;
                    }
                    if(logfolder)
                    {
                        logFolderName.innerText=logfolder;
                    }
                    if(fileText)
                    {
                        var doc=editor.state.doc;
                        let transaction = editor.state.update({changes: {from: 0, to: doc.length, insert: fileText}})
                        editor.dispatch(transaction);
                        editor.state.values[0].done=[];
                        editor.state.values[0].undone=[];
                    }
                    if(filename)
                    {
                        filenameBox.value=filename;
                    }
                });
            }
            editorListener=function(update)
            {
                if(update.docChanged)
                {
                    // make save button have * after it
                    if(editor.state.values[0].done.length>1 || (editor.state.values[0].done.length==1 && editor.state.values[0].done[0].changes))
                    {
                        saveButton.disabled=false;
                    }else
                    {
                        saveButton.disabled=true;
                    }
                }
            }

        }
{% endif %}

        const {EditorState, EditorView, basicSetup} = CM["@codemirror/basic-setup"];
        const {indentUnit} = CM["@codemirror/language"]
        const {python, pythonLanguage} = CM["@codemirror/lang-python"];
        const {completeFromList} = CM["@codemirror/autocomplete"];
        const {drawSelection,keymap} = CM["@codemirror/view"];
        const {defaultTabBinding,indentLess,indentMore} = CM["@codemirror/commands"]

        // if we have an editor, then show that
        editorDiv=document.createElement("div");
        if(options.hasReadOnlyCode)
        {
            editorDiv.className="pyodide_code_readonly";        
        }else
        {
            editorDiv.className="pyodide_code";
        }
        parent.appendChild(editorDiv);
        function tabber(target)
        {
            var dispatch=target.dispatch;
            var state=target.state;
            if(state.selection.ranges.length>1
             || state.selection.ranges.length==1 && !state.selection.ranges[0].empty)
            {
                // something selected, do indent
                return indentMore(target)
            }else
            {
                // nothing selected, insert spaces at anchor
                // up to current tab column
                var pos=state.selection.ranges[0].anchor;
                var line=state.doc.lineAt(pos);
                var col=pos-line.from;
                // we need to go to multiple of 4 spaces
                var numSpaces=4-(col%4);
                var spaces="";
                for(let c=0;c<numSpaces;c++)
                {
                    spaces+=" ";
                }
                dispatch({changes:{from:pos,to:pos,insert:spaces},
                            selection:{anchor:pos+numSpaces} });
                return true;
            }
        } 
        let extensions=[
            basicSetup,EditorState.tabSize.of(4),
            python(),
            drawSelection(),
            indentUnit.of("    "),
            keymap.of([{key:"Tab",run:tabber,shift:indentLess}])            
    ];
        if(editorListener)
        {
            extensions.push(EditorView.updateListener.of(editorListener));

        }
        if(options.hasReadOnlyCode)
        {
            extensions.push(EditorView.editable.of(false))
        }
        let state = EditorState.create(
            {                
                
                doc: codeValue,
                extensions: extensions
            });            
       editor=new EditorView({state, parent:editorDiv});        
    }


    if(options.hasConsole)
    {
        // make a div for the console and add it to parent
        consoleDiv=document.createElement("div");
        consoleDiv.className="pyodide_console";
        parent.appendChild(consoleDiv);
        consoleObj=new Console(consoleDiv)
    }
    if(options.hasGraph)
    {
        // make a graph canvas
        graphCanvas=document.createElement("canvas");
        graphCanvas.className="pyodide_graph";
//        graphCanvas.width=512;
//        graphCanvas.height=256;
        parent.appendChild(graphCanvas);         
        graphContext=makeGraphContext(graphCanvas);
    }
    // add a run button which starts all sensors, sets 
    // correct console div and graph canvas and runs the 
    // python code
    async function onRun()
    {
        // request permissions
        // n.b. this has to happen first before we do 
        // anything async or else safari won't let
        // us request sensor access (has to be directly from
        // a click event) 
        let permissionRequesters=[]
        for(let c in window.sensor_objects)
        {
            const o=window.sensor_objects[c];
            if(o.requestPermissions)
            {
                permissionRequesters.push(o.requestPermissions());
            }
        }
        // now we have done everything that needs to be non-async
        // so we can await promises with wild abandon
        await Promise.all(permissionRequesters);

        // stop anything else that is running
        await asyncRun("abort","rerun");
        // set the graph to point at our graph
        pyodide_graph_context=graphContext
        // set the console to point at our console
        pyodide_console=consoleObj;
        // clear our console output
        consoleObj.clear();
        // set the graph to point at our graph
        // load our code string from editor
        // if there is one
        // run the code
        for(let c in window.sensor_objects)
        {
            const o=window.sensor_objects[c];
            if(o.start)
            {
                await o.start(sensorCallback.bind(null,o.name));
            }
        }

        stopButton.disabled=false;
        startButton.disabled=true;

        codeValue=editor.state.doc.toString();
        running=true;
        await asyncRun("run",codeValue);
        running=false;
{% if page.uses_files %}
        // make really sure that the console is saved
        consoleObj.save();
{% endif %}

        for(let c in window.sensor_objects)
        {
            const o=window.sensor_objects[c];
            if(o.stop)
            {
                await o.stop()
            }
        }
        stopButton.disabled=true;
        startButton.disabled=false;
    }
    // add a stop button which cancels everything remote
    // and stops sensors
    async function onStop()
    {
        // stop sensors or anything here 
        // to avoid sending loads of 
        // messages to stopped python
        running=false;
        await asyncRun("abort","cancel");
    }

    const startButton=document.createElement("button");
    startButton.className="pyodide_start";        
    startButton.innerText="Start";
    startButton.disabled=true;
    startButton.onclick=onRun;
    parent.appendChild(startButton);
    const stopButton=document.createElement("button");
    stopButton.className="pyodide_stop";        
    stopButton.innerText="Stop";
    stopButton.disabled=true;
    stopButton.onclick=onStop;
    parent.appendChild(stopButton);
{% if page.uses_files %}
    const logs_div=document.createElement("div");
    const captureCheck=document.createElement("input");
    captureCheck.type="checkbox"
    const captureText=document.createElement("label")
    captureText.innerText="Autosave output"
    captureCheck.id="captureCheck_"+box_index;

    const saveConsoleFn=
            (filename,txt)=>{

            if(captureCheck.checked)
            {
                // save output to dated file
                oneDriveSaveConsoleLog(txt,filename);
                return true;
            }
        };
    consoleObj.setSaveFn(saveConsoleFn);

    captureCheck.addEventListener("change",async (event)=>{
        if(captureCheck.checked)
        {
            var captureFolder=await oneDriveFolderName(true);
            if(!captureFolder)
            {
                var folderName=await oneDriveChooseFolder("",true);
                logFolderName.textContent=foldername;            
            }
            consoleObj.save();
        }
    });


    captureText["htmlFor"]=captureCheck.id;

    logs_div.appendChild(captureCheck);
    logs_div.appendChild(captureText)
    const chooseOutputFolderButton=document.createElement("button");
    chooseOutputFolderButton.className="pyodide_stop";        
    chooseOutputFolderButton.innerText="Output folder...";
    const logFolderName=document.createElement("span");
    logFolderName.textContent="    ";
    chooseOutputFolderButton.onclick=function()
    {
        oneDriveChooseFolder("",true).then(function(foldername)
        {
            logFolderName.textContent=foldername;            
        });        
    }
    logs_div.appendChild(chooseOutputFolderButton);
    logs_div.appendChild(logFolderName);
    parent.appendChild(logs_div);
{% endif %}


    if(figureCap)
    {
        figure.appendChild(figureCap);
    }
    if(consoleDiv)
    {
        consoleDiv.innerText="Python loading";
    }
    // only allow starting code once pyodide is actually running
    pythonInitPromise.then( function(){
        if(consoleDiv)
        {
            consoleDiv.innerText="Python ready, press start button to run code";
        }
        startButton.disabled=false;
    });        
}

window.makePyodideBoxInternal=makePyodideBoxInternal;

let running=false;
let pythonInited=false;
const pyodideWorker = new FakeWorker('{{ "/assets/js/async_worker.js"| relative_url }} ')
//const pyodideWorker = new Worker('{{ "/assets/js/async_worker.js"| relative_url }} ')
pyodideWorker.onmessage = onRemoteMessage;
pyodideWorker.onerror = onRemoteError;

let pyodide_console=undefined;
let pyodide_graph_context=undefined;
let lastMessage=1;

function writeConsole(msg)
{
    if(pyodide_console)
    {
        pyodide_console.write(msg);
    }
}

function sensorCallback(name,...args)
{
    // don't send any more sensor messages 
    // after stop button is pressed
    if(!running)
    {
        return;
    }
    
    lastMessage++;
    // don't expect any response to this
    pyodideWorker.postMessage({
        cmd: "sensor",
        arg: {name:name,args:args},
        id: lastMessage
    });    
}

function onRemoteError(event)
{
    console.log("ERROR in worker",event)
}

async function onRemoteMessage(event)
{   
    let msgData=event.data;
    if(msgData["type"]=="console")
    {
        var logDiv=document.getElementById("LOGDIV");
        if(logDiv)
        {
            logDiv.appendChild(document.createTextNode(msgData["text"]));
        }
    }else if(msgData["type"]=="speech")
    {
        if(msgData["say"])
        {
            let utterance = new SpeechSynthesisUtterance(msgData["say"]);
            speechSynthesis.speak(utterance);            
        }   
    }
    else if(msgData["type"]=="graph")
    {
        if(pyodide_graph_context)
        {
            if (msgData["fn"]=="style")
            {
                pyodide_graph_context.setGraphStyle.apply(pyodide_graph_context,msgData.arguments)
            }else if(msgData["fn"]=="data")
            {
                pyodide_graph_context.onGraphValue.apply(pyodide_graph_context,msgData.arguments)
            }
        }
    }
    else if(msgData["type"]=="stdout" || msgData["type"]=="stderr")
    {
        writeConsole(msgData["text"]);
    }else if(msgData["type"]=="response")
    {
        let msgID=msgData["id"];
        if(responseWaiter[msgID])
        {
            let p=responseWaiter[msgID];
            p(msgData);
            responseWaiter[msgID]=undefined;
        }
    }
} 

async function asyncRun(cmd,arg){
    lastMessage++;
    let thisMessage=lastMessage;
    let p=new Promise((r,e)=>{responseWaiter[thisMessage]=(r)});
    pyodideWorker.postMessage({
        cmd: cmd,
        arg: arg,
        id: thisMessage
    });
    try
    {
        var responseData=await p;
        return responseData;
    }catch(e)
    {
        console.log("Error in asyncRun:",e);
    }
}

// init pyodide on page load
// so hopefully it will be ready by the time anyone 
// looks at that content
async function initFn()
{
    // reload any script files that have updated since last reload    
    // this is the github checkin we're looking at
    let currentRevision="{{ site.github.build_revision }}";
    const lastRevision=localStorage.getItem('lastRevision');
    if (lastRevision && lastRevision!=currentRevision)
    {
        let updatePromiseList=[];
        let compareURL="{{site.github.api_url}}/repos/{{site.github.owner_name}}/{{site.github.repository_name}}/compare/"+lastRevision+"..."+currentRevision;
        let compareJSON=await (await fetch(compareURL)).json();
        for(let i in compareJSON.files)
        {
            let fname=compareJSON.files[i].filename;
            if(fname.endsWith(".js") || fname.endsWith(".py"))
            {
                console.log("Updating:",fname);
                updatePromiseList.push(fetch(fname,{cache:"no-cache"}));
            }
        }
        await Promise.all(updatePromiseList);
        localStorage.setItem('lastRevision',currentRevision);
    }
    async function initSensors()
    {
        for(let c in window.sensor_objects)
        {
            const o=window.sensor_objects[c];
            if(o.init)
            {
                await o.init()
            }
        }
    }

    async function initPython()
    {
        await asyncRun("init","noconsole");
        pythonInited=true;
        window.dispatchEvent(new Event("pythoninited"));
    }
    // start init python on page load in the hope it is
    // done by the time it is needed
    pythonInitPromise=initPython();

    let promiseList=[];
    for(let box in window.queued_pyodide_boxes)
    {
        promiseList.push(makePyodideBoxInternal(queued_pyodide_boxes[box]))        
    }
    await Promise.all(promiseList);
    window.dispatchEvent(new Event("pythonboxesmade"));
    await initSensors();

}

window.addEventListener('load',initFn);

</script>